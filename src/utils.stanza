defpackage poet/utils:
    import core
    import core/parsed-path

public defn error-with-usage (msg: Printable|String) -> Void:
  error(msg, true)

public defn error (msg: Printable|String) -> Void:
  error(msg, false)

defn error (msg: Printable|String, usage?: True|False) -> Void:
  val program = command-line-arguments()[0]
  println(STANDARD-ERROR-STREAM, "%_: %_" % [program, msg])
  if usage?:
    println(STANDARD-ERROR-STREAM, "usage: %_ [build|init|add]" % [program])
  exit(1)

defn and-then<?T, ?U> (v: ?T|False, f: (T) -> ?U) -> U|False:
  match(v):
    (_: False): false
    (t: T): f(t)

public defn unwrap<?T> (v?: ?T|False) -> T:
  match(v?):
    (_: False): fatal("unwrapped false value")
    (v: T): v

public defn open (f: (FileOutputStream) -> False, path: String, append?: True|False) -> False:
  val file = FileOutputStream(path, append?)
  try: f(file)
  finally: close(file)

lostanza val GET-CWD-BUFF-SIZE: long = 0x1000L
extern getcwd: (ptr<byte>, long) -> ptr<byte>

public lostanza defn get-cwd () -> ref<String>:
  val buff = call-c clib/malloc(GET-CWD-BUFF-SIZE)
  call-c getcwd(buff, GET-CWD-BUFF-SIZE)
  val ret = String(buff)
  call-c clib/free(buff)
  return ret

public defn strip-end (s: String, strip: String) -> String:
  if s[(length(s) - length(strip)) to false] == strip:
    s[0 to length(s) - length(strip)]
  else:
    s

public defn split (s: String, delim: Char) -> [String, String]|False:
  match(index-of-char(s, delim)):
    (i: Int): [s[0 to i], s[(i + 1) to false]]
    (_): false

public defn split-last (s: String, delim: Char) -> [String, String]|False:
  match(last-index-of-char(s, delim)):
    (i: Int): [s[0 to i], s[(i + 1) to false]]
    (_): false

public defn dirname (path: String) -> String|False:
  split-last(path, '/') $> and-then{_, {_[1]}}

public defn create-empty-file (path: String) -> False:
  spit(path, "")

public defn run-command-throw-on-error (
  args: Tuple<String>,
  error: Exception|Printable|String
) -> Int:
  defn throw-if-non-zero (code: Int) -> Int:
    if code != 0:
      throw $ match(error):
        (e: Exception): e
        (e: Printable|String): Exception(to-string(e))
    code
  val process = Process(args[0], args)
  match(wait(process)):
    (code:ProcessDone): throw-if-non-zero(value(code))
    (_): throw-if-non-zero(-1)

public defn run-git-command-in-dir (work-tree: String, args0: Tuple<String>) -> Int:
  val git-dir = to-string("%_/.git/" % [work-tree])
  val base-args = ["git", "--git-dir", git-dir, "--work-tree", work-tree]
  val args = to-tuple $ cat(base-args, args0)
  run-command-throw-on-error(args, "'%_' failed!" % [string-join(args, " ")])

public defn shallow-clone-git-repo (url: String, directory: String) -> Int:
  run-command-throw-on-error(["git", "clone", url, "--depth", "1", directory],
                             "'git clone %_' failed!" % [url])

public defn git-init (path: String) -> Int:
  run-command-throw-on-error(["git", "init", path],
                             "'git init %_' failed!" % [path])

public defn delete-files-in-dir (path: String) -> False:
  val dir-path = parse-path(path)
  for file in dir-files(path) do:
    val file-path = to-string $ relative-to-dir(dir-path, file)
    if file-type(file-path, false) is DirectoryType:
      delete-recursive(file-path)
    else:
      delete-file(file-path)

public defn nth?<?T> (c: IndexedCollection<?T>, n: Int) -> Maybe<T>:
  if n < length(c):
    One(get(c, n))
  else:
    None()

public defn last?<?T> (c: IndexedCollection<?T>) -> Maybe<T>:
  if length(c) == 0:
    None()
  else:
    One(get(c, length(c) - 1))

public defn base-name? (path: String) -> Maybe<String>:
  last?(entries(parse-path(path)))
