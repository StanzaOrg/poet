defpackage poet/utils:
    import core
    import core/parsed-path
    import collections
    import maybe-utils

defn program-name () -> String:
  val program-path = command-line-arguments()[0]
  value-or(base-name?(program-path), program-path)

public defn error-with-usage (msg: Printable|String) -> Void:
  error(msg, true)

public defn error (msg: Printable|String) -> Void:
  error(msg, false)

public defn info (msg: Printable|String) -> False:
  println("%_: %_" % [program-name(), msg])

defn error (msg: Printable|String, usage?: True|False) -> Void:
  println(STANDARD-ERROR-STREAM, "%_: %_" % [program-name(), msg])
  if usage?:
    println(STANDARD-ERROR-STREAM, "usage: %_ [build|clean|init|publish]" % [program-name()])
  exit(1)

public defn unwrap<?T> (v?: ?T|False) -> T:
  match(v?):
    (_: False): fatal("unwrapped false value")
    (v: T): v

public defn open (f: (FileOutputStream) -> False, path: String, append?: True|False) -> False:
  val file = FileOutputStream(path, append?)
  try: f(file)
  finally: close(file)

lostanza val GET-CWD-BUFF-SIZE: long = 0x1000L
extern getcwd: (ptr<byte>, long) -> ptr<byte>

public lostanza defn get-cwd () -> ref<String>:
  val buff = call-c clib/malloc(GET-CWD-BUFF-SIZE)
  call-c getcwd(buff, GET-CWD-BUFF-SIZE)
  val ret = String(buff)
  call-c clib/free(buff)
  return ret

public defn strip-end (s: String, strip: String) -> String:
  if s[(length(s) - length(strip)) to false] == strip:
    s[0 to length(s) - length(strip)]
  else:
    s

public defn split-last (s: String, delim: Char) -> Maybe<[String, String]>:
  last-index-of-char(s, delim) $> to-maybe $> map{_, fn (i):
    [s[0 to i], s[(i + 1) to false]]
  }

public defn dirname (path: String) -> Maybe<String>:
  defn first<?T> (t: Tuple<?T>) -> T: (t[1])
  split-last(path, '/') $> map{_, first}

public defn create-empty-file (path: String) -> False:
  spit(path, "")

public defstruct ProcessBuilder:
  args: Tuple<String>
  working-dir?: Maybe<String> with: (default => None())
  output?: True|False with: (default => false)

public defn with-output (builder: ProcessBuilder) -> ProcessBuilder:
  ProcessBuilder(args(builder), working-dir?(builder), true)

public defn in-dir (builder: ProcessBuilder, dir: String) -> ProcessBuilder:
  ProcessBuilder(args(builder), One(dir), output?(builder))

public defn build (builder: ProcessBuilder) -> Process:
  val args = args(builder)
  val output-stream = if output?(builder): (PROCESS-OUT) else: (STANDARD-OUT)
  val working-dir? = working-dir?(builder)
  match(working-dir?: One<String>):
    Process(args[0], args, STANDARD-IN, output-stream, STANDARD-ERR, value!(working-dir?))
  else:
    Process(args[0], args, STANDARD-IN, output-stream, STANDARD-ERR)

public defn get-output (p: Process) -> String:
  slurp-stream(output-stream(p))

public defn wait-process-throw-on-nonzero (
  process: Process
  error: Exception|Printable|String
) -> Int:
  defn throw-if-non-zero (code: Int) -> Int:
    if code != 0:
      throw $ match(error):
        (e: Exception): e
        (e: Printable|String): Exception(to-string(e))
    code
  match(wait(process)):
    (code:ProcessDone): throw-if-non-zero(value(code))
    (_): throw-if-non-zero(-1)

public defn slurp-stream (s: InputStream) -> String:
  val buffer = StringBuffer()
  defn* loop () :
    match(get-char(s)) :
      (c:Char) :
        add(buffer, c)
           loop()
      (c:False) :
        to-string(buffer)
  loop()

public defn run-command-throw-on-error (
  args: Tuple<String>
  error: Exception|Printable|String
) -> Int:
  wait-process-throw-on-nonzero(Process(args[0], args), error)

public defn command-output-in-dir (
  args: Tuple<String>,
  dir: String,
  fail?: True|False
) -> String:
  val proc = ProcessBuilder(args)
    $> in-dir{_, dir}
    $> with-output
    $> build
  val ret = proc $> get-output $> trim
  if fail?:
    wait-process-throw-on-nonzero(proc, "'%s' failed!" % [args])
  ret

public defn delete-file? (path: String) -> False:
  try:
    delete-file("poet.lock")
  catch (_: FileDeletionError):
    false

public defn delete-files-in-dir (path: String) -> False:
  val dir-path = parse-path(path)
  for file in dir-files(path) do:
    val file-path = to-string $ relative-to-dir(dir-path, file)
    if file-type(file-path, false) is DirectoryType:
      delete-recursive(file-path)
    else:
      delete-file(file-path)

public defn nth?<?T> (c: IndexedCollection<?T>, n: Int) -> Maybe<T>:
  if n < length(c):
    One(get(c, n))
  else:
    None()

public defn last?<?T> (c: Seqable<?T>) -> Maybe<T>:
  let loop (s = to-seq(c), last = None()):
    if empty?(s):
      last
    else:
      loop(s, One(next(s)))

public defn max?<?T> (c: Seqable<?T>) -> Maybe<T>:
  defn max* (a: Maybe<T>, b: Maybe<T>) -> Maybe<T>:
    if a is None: (b)
    if b is None: (a)
    if a > b: (a) else: (b)
  let loop (s = to-seq(c), max = None()):
    if empty?(s):
      max
    else:
      loop(s, max*(max, One(next(s))))

public defn inspect<?T> (c: Seqable<?T>) -> Seq<T>:
  println("debug: %s" % [c])
  for e in c seq:
    e

public defn base-name? (path: String) -> Maybe<String>:
  path
    $> entries{parse-path(_)}
    $> map{format{ParsedPath([_]), CURRENT-PLATFORM}, _}
    $> last?
    $> map{_, to-string}

public defn remove-prefix? (path: String, prefix: String) -> String:
  if prefix?(path, prefix):
    path[length(prefix) to false]
  else:
    path
