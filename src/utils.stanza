defpackage poet/utils:
    import core
    import core/parsed-path
    import collections
    import maybe-utils

public defn error-with-usage (msg: Printable|String) -> Void:
  error(msg, true)

public defn error (msg: Printable|String) -> Void:
  error(msg, false)

defn error (msg: Printable|String, usage?: True|False) -> Void:
  val program = command-line-arguments()[0]
  println(STANDARD-ERROR-STREAM, "%_: %_" % [program, msg])
  if usage?:
    println(STANDARD-ERROR-STREAM, "usage: %_ [add|build|clean|init]" % [program])
  exit(1)

public defn unwrap<?T> (v?: ?T|False) -> T:
  match(v?):
    (_: False): fatal("unwrapped false value")
    (v: T): v

public defn open (f: (FileOutputStream) -> False, path: String, append?: True|False) -> False:
  val file = FileOutputStream(path, append?)
  try: f(file)
  finally: close(file)

lostanza val GET-CWD-BUFF-SIZE: long = 0x1000L
extern getcwd: (ptr<byte>, long) -> ptr<byte>

public lostanza defn get-cwd () -> ref<String>:
  val buff = call-c clib/malloc(GET-CWD-BUFF-SIZE)
  call-c getcwd(buff, GET-CWD-BUFF-SIZE)
  val ret = String(buff)
  call-c clib/free(buff)
  return ret

public defn strip-end (s: String, strip: String) -> String:
  if s[(length(s) - length(strip)) to false] == strip:
    s[0 to length(s) - length(strip)]
  else:
    s

public defn split (s: String, delim: Char) -> Maybe<[String, String]>:
  index-of-char(s, delim) $> to-maybe $> map{_, fn (i):
    [s[0 to i], s[(i + 1) to false]]
  }

public defn split-last (s: String, delim: Char) -> Maybe<[String, String]>:
  last-index-of-char(s, delim) $> to-maybe $> map{_, fn (i):
    [s[0 to i], s[(i + 1) to false]]
  }

public defn dirname (path: String) -> Maybe<String>:
  defn first<?T> (t: Tuple<?T>) -> T: (t[1])
  split-last(path, '/') $> map{_, first}

public defn create-empty-file (path: String) -> False:
  spit(path, "")

public defstruct ProcessBuilder:
  args: Tuple<String>
  working-dir?: Maybe<String> with: (default => None())
  output?: True|False with: (default => false)

public defn with-output (builder: ProcessBuilder) -> ProcessBuilder:
  ProcessBuilder(args(builder), working-dir?(builder), true)

public defn in-dir (builder: ProcessBuilder, dir: String) -> ProcessBuilder:
  ProcessBuilder(args(builder), One(dir), output?(builder))

public defn build (builder: ProcessBuilder) -> Process:
  val args = args(builder)
  val output-stream = if output?(builder): (PROCESS-OUT) else: (STANDARD-OUT)
  val working-dir? = working-dir?(builder)
  match(working-dir?: One<String>):
    Process(args[0], args, STANDARD-IN, output-stream, STANDARD-ERR, value!(working-dir?))
  else:
    Process(args[0], args, STANDARD-IN, output-stream, STANDARD-ERR)

public defn wait-process-throw-on-nonzero (
  process: Process
  error: Exception|Printable|String
) -> Int:
  defn throw-if-non-zero (code: Int) -> Int:
    if code != 0:
      throw $ match(error):
        (e: Exception): e
        (e: Printable|String): Exception(to-string(e))
    code
  match(wait(process)):
    (code:ProcessDone): throw-if-non-zero(value(code))
    (_): throw-if-non-zero(-1)

public defn slurp-stream (s: InputStream) -> String:
  val buffer = StringBuffer()
  defn* loop () :
    match(get-char(s)) :
      (c:Char) :
        add(buffer, c)
           loop()
      (c:False) :
        to-string(buffer)
  loop()

public defn run-command-throw-on-error (
  args: Tuple<String>
  error: Exception|Printable|String
) -> Int:
  wait-process-throw-on-nonzero(Process(args[0], args), error)

public defn is-git-repo-dirty? (work-tree: String) -> True|False:
  val git-ls = ProcessBuilder(["git", "status", "-z"])
    $> in-dir{_, work-tree}
    $> with-output
    $> build
  val output = slurp-stream(output-stream(git-ls))
  not empty?(output)

public defn run-git-command-in-dir (work-tree: String, args0: Tuple<String>) -> Int:
  val args = to-tuple $ cat(["git"], args0)
  val process = ProcessBuilder(args) $> in-dir{_, work-tree} $> build
  wait-process-throw-on-nonzero(process, "'%_' failed!" % [string-join(args, " ")])

public defn shallow-clone-git-repo (url: String, directory: String) -> Int:
  run-command-throw-on-error(["git", "clone", url, "--depth", "1", directory],
                             "'git clone %_' failed!" % [url])

public defn git-init (path: String) -> Int:
  run-command-throw-on-error(["git", "init", path],
                             "'git init %_' failed!" % [path])

public defn delete-files-in-dir (path: String) -> False:
  val dir-path = parse-path(path)
  for file in dir-files(path) do:
    val file-path = to-string $ relative-to-dir(dir-path, file)
    if file-type(file-path, false) is DirectoryType:
      delete-recursive(file-path)
    else:
      delete-file(file-path)

public defn nth?<?T> (c: IndexedCollection<?T>, n: Int) -> Maybe<T>:
  if n < length(c):
    One(get(c, n))
  else:
    None()

public defn last?<?T> (c: IndexedCollection<?T>) -> Maybe<T>:
  if length(c) == 0:
    None()
  else:
    One(get(c, length(c) - 1))

public defn base-name? (path: String) -> Maybe<String>:
  path
    $> entries{parse-path(_)}
    $> map{to-string, _}
    $> to-vector<String>{_}
    $> last?{_}
