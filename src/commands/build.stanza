defpackage poet/commands/build:
  import core
  import collections
  import maybe-utils
  import poet/config
  import poet/utils
  import toml/parser
  import toml/file
  import toml/table
  import toml/value

defn parse-poet-lock-file (path: String) -> HashTable<String, String>:
  slurp(path)
    $> parse-file
    $> table
    $> to-seq
    $> seq{fn (kv): key(kv) => value(kv) as String , _}
    $> to-hashtable<String, String>

defn sync-dependency (dep: Dependency, hash?: Maybe<String>, ref?: Maybe<String>):
  defn repo-head-at-hash? () -> True|False:
    hash?
      $> map{_, {_ == git-rev-parse(path(dep), "HEAD")}}
      $> value-or{_, false}

  defn git (args: Tuple<String>):
    run-git-command-in-dir(path(dep), args)

  if not repo-head-at-hash?():
    println("debug: syncing '%_'" % [spec(dep)])

    val ref = ref? $> value-or{_, "HEAD"}
    val reset-ref = if ref == "HEAD":
      "origin/HEAD"
    else:
      ref

    git(["fetch", "--quiet", "--force", "origin", ref])
    git(["reset", "--quiet", "--hard", reset-ref])

defn clone-and-checkout-dependency (dep: Dependency):
  println("poet: build: cloning %_" % [spec(dep)])
  shallow-clone-git-repo(uri(dep), path(dep))

  defn parse-version (version: String) -> Maybe<[Int, Int, Int]>:
    defn malformed () -> Void:
      error(\<>poet: build: malformed version '%_' in poet.toml:
%_ = "%_|%_" <> % [version, name(dep), uri(dep), version])

    val elements = to-tuple $ split(version, ".")
    if length(elements) == 3:
      val major = elements[0] $> to-int $> to-maybe $> value-or-else{_, malformed}
      val minor = elements[1] $> to-int $> to-maybe $> value-or-else{_, malformed}
      val patch = elements[2] $> to-int $> to-maybe $> value-or-else{_, malformed}
      One([major, minor, patch])
    else:
      None()

  defn version-tag ([major, minor, patch]: [Int, Int, Int]) -> String:
    to-string("v%~.%~.%~" % [major, minor, patch])

  version?(dep)
    $> and-then{_, parse-version}
    $> map{_, version-tag}
    $> map{_, run-git-command-in-dir{path(dep), ["checkout", "--quiet", _]}}
    $> value-or{_, false}

defn ensure-poet-dir-structure-exists () -> False:
  defn create-dir! (path: String) -> True|False:
    if not file-exists?(path):
      create-dir(path)
      true

  if create-dir!(".poet/"):
    create-dir!(".poet/deps/")
    create-dir!(".poet/pkgs/")

  false

defstruct Dependency:
  name: String
  uri: String
  version?: Maybe<String>

defn path (dep: Dependency) -> String:
  to-string $ ".poet/deps/%_" % [name(dep)]

defn spec (dep: Dependency) -> String:
  to-string $ "%_|%_"
    % [name(dep), version?(dep) $> value-or{_, "latest"}]

defn parse-dependency (name: String, locator: String) -> Maybe<Dependency>:
  val elements = to-tuple $ split(locator, "|")

  if length(elements) $> contains?{[1, 2], _}:
    val uri = elements[0]
    val version? = One(elements[1]) when length(elements) > 1 else None()
    One(Dependency(name, uri, version?))
  else:
    None()

defn fetch-and-sync-dependencies () -> False:
  val resolved-dependencies = HashSet<String>()
  val dependency-hashes = if file-exists?("poet.lock"):
    parse-poet-lock-file("poet.lock")
  else:
    HashTable<String, String>()

  defn parse-config-and-fetch-dependencies (poet-toml-path: String) -> False:
    if not file-exists?(poet-toml-path):
      throw $ Exception $
        "tried to fetch dependencies from `%_`, but it doesn't exist!"
         % [poet-toml-path]

    val dependencies? = parse-config(poet-toml-path)
      $> get?{_, "dependencies"}

    match(dependencies?: One<TomlValue>):
      val child-deps = Vector<Dependency>()

      for dep in value!(dependencies?) as TomlTable do:
        val dependency = parse-dependency(key(dep), value(dep) as String)
          $> value-or-else{_, {
            error("build: malformed dependency '%_' given in '%_': '%_'"
                  % [key(dep), path, value(dep) as String])
          }}

        if not get(resolved-dependencies, name(dependency)):
          add(resolved-dependencies, name(dependency))

          val hash? = get?(dependency-hashes, name(dependency)) $> to-maybe
          if file-exists?(path(dependency)):
            sync-dependency(dependency, hash?, version?(dependency))
          else:
            clone-and-checkout-dependency(dependency)

          add(child-deps, dependency)
          if hash? is None:
            set(dependency-hashes, name(dependency),
              git-rev-parse(path(dependency), "HEAD"))

      for dep in child-deps do:
        parse-config-and-fetch-dependencies $
          to-string("%_/poet.toml" % [path(dep)])

  parse-config-and-fetch-dependencies("poet.toml")
  write-poet-lock-file(dependency-hashes, "poet.lock")

  within f = open(".poet/stanza.proj", false):
    for dep in resolved-dependencies do:
      println(f, to-string(\<>include "deps/%_/stanza.proj"<> % [dep]))
    println(f, \<>include "../stanza.proj"<>)

defn write-poet-lock-file (
  dependency-hashes: HashTable<String, String>,
  path: String
) -> False:
  dependency-hashes
    $> to-seq
    $> TomlFile
    $> spit{path, _}

public defn build (args0: Tuple<String>) -> False:
  ensure-poet-dir-structure-exists()
  fetch-and-sync-dependencies()

  val poet-dir = to-string $ "%_/.poet" % [get-cwd()]

  val args = to-tuple $ cat-all([["stanza", "build"], args0, ["-pkg", "pkgs"]])
  ProcessBuilder(args)
    $> in-dir{_, poet-dir}
    $> build
    $> wait-process-throw-on-nonzero{_, "build failed!"}
    
  false
