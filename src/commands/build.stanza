defpackage poet/commands/build:
  import core
  import collections
  import maybe-utils
  import poet/config
  import poet/utils
  import poet/dependency
  import semver
  import toml/parser
  import toml/file
  import toml/table
  import toml/value

defn parse-package-specification (path: String) -> TomlTable:
  path
    $> parse-config
    $> toml
    $> table

defn sync-dependency (
  dep: Dependency,
  hash?: Maybe<String>,
  force?: True|False,
) -> True|False:

  val head-hash = git-rev-parse!(path(dep), "HEAD")
  defn repo-head-at-hash? () -> True|False:
    hash?
      $> map{_, {_ == head-hash}}
      $> value-or{_, false}

  defn git (args: Tuple<String>):
    run-git-command-in-dir(path(dep), args)

  val up-to-date? = repo-head-at-hash?()

  if not up-to-date?:
    if hash? is One:
      if force?:
        info("build: syncing '%_'" % [spec(dep)])

        val ref = ref(dep)
        val reset-ref = ref when ref != "HEAD" else "origin/HEAD"

        git(["fetch", "--quiet", "--force", "origin", ref])
        git(["reset", "--quiet", "--hard", reset-ref])
      else:
        error(\<>build: dependency '%_' version does not match version in poet.lock.
Either remove poet.lock or run `poet clean`<> % [name(dep)])

  up-to-date?

deftype Version
defstruct IntVersion <: Version:
  major: Int
  minor: Int
  patch: Int

defstruct LatestVersion <: Version

defn parse-version (version: String) -> Maybe<Version>:
  if version == "latest":
    One(LatestVersion())
  else:
    defn parse-int! (s: String) -> Int:
      s $> to-int $> to-maybe $> value!

    val elements = to-tuple $ split(version, ".")
    if length(elements) == 3:
      val major = elements[0] $> parse-int!
      val minor = elements[1] $> parse-int!
      val patch = elements[2] $> parse-int!
      One(IntVersion(major, minor, patch))
    else:
      None()

defmulti version-tag? (version: Version) -> Maybe<String>
defmethod version-tag? (version: IntVersion) -> Maybe<String>:
  One $ to-string("v%~.%~.%~" % [major(version), minor(version), patch(version)])

defmethod version-tag? (version: LatestVersion) -> None:
  None()

defn clone-and-checkout-dependency (dep: Dependency) -> False:
  info("build: cloning %_" % [spec(dep)])
  debug("build: clone: %_" % [uri(dep)])

  shallow-clone-git-repo(uri(dep), path(dep))
  val revision = version(dep)
    $> parse-version
    $> and-then{_, version-tag?}
    $> map{_, fn (tag):
      val refspec = to-string $ "+refs/tags/%_:refs/tags/%_" % [tag, tag]
      run-git-command-in-dir(path(dep), ["fetch", "--quiet", "origin", refspec])
      run-git-command-in-dir(path(dep), ["checkout", "--quiet", "--force", tag])
    }
  false

defn ensure-poet-dir-structure-exists () -> False:
  defn create-dir! (path: String) -> True|False:
    if not file-exists?(path):
      create-dir(path)
      true

  if create-dir!(".poet/"):
    create-dir!(".poet/deps/")
    create-dir!(".poet/pkgs/")

  false

deftype DependencyResolver
  

defn DependencyResolver (lock-hashes: HashTable<String, String>):
  val resolved-dependencies = HashSet<String>()

  new DependencyResolver:
    defmethod add (this, dependency: String) -> False:
      add(resolved-dependencies, dependency)

    defmethod set-lock-hash (this, dependency: String, hash: String) -> False:
      lock-hashes[dependency] = hash

    defmethod resolved-dependencies (this) -> HashSet<String>:
      resolved-dependencies

    defmethod resolved? (this, dependency: Dependency) -> True|False:
      get(resolved-dependencies, name(dependency))

    defmethod resolve (this, dependency: Dependency) -> False:
      add(resolver, name(dependency))

      val lock-hash? = to-maybe $ get?(lock-hashes(resolver), name(dependency))
      val dep-was-already-in-sync? = if file-exists?(path(dependency)):
        sync-dependency(dependency, lock-hash?, false)
      else:
        clone-and-checkout-dependency(dependency)

      if not in-sync? and lock-hash? is None:
        val lock-hash = git-rev-parse!(path(dependency), "HEAD")
        set-lock-hash(resolver, name(dependency), lock-hash)

defn fetch-and-sync-dependencies () -> False:
  ; The overall procedure is to:
  ;   1. Parse the `poet.lock` file, if it exists.
  ;
  ;   2. Parse the `poet.toml` file for a package specification.
  ;
  ;   3. From the specification, parse the list of dependencies
  ;     a. For each dependency, check if it is resolved:
  ;       - It is present on disk
  ;       - If a lock hash exists for it, its hash matches
  ;       - Its version is compatible with the version specified in `poet.toml`
  ;
  ;     b. For each dependency that is not resolved:
  ;       - If it is not present on disk, clone it at the specified version.
  ;       - If a lock hash is present and different than its hash, error
  ;       - If its version is different than the requested version, check if it is compatible.
  ;          - If it is compatible, advance the dependency to the greater of the two
  ;          - Else, error
  ;
  ;   3. Repeat step 3 with the child package specifications, continuing until there are
  ;      no more dependencies to resolve.
  ;
  ;   4. Return the total list of dependencies and their hashes

  val lock-hashes = parse-poet-lock-file?("poet.lock") $>
    value-or{_, HashTable<String, String>()}

  val resolved-dependencies = HashTable<String, SemanticVersion>()

  val package = parse-package-specification("poet.toml")
  val dependencies = package["dependencies"]
  for [name, locator] in pairs(dependencies) do:
    val dependency = parse-dependency(name, locator as String)

    if not file-exists?(path(dependency)):
      clone-and-checkout-dependency(dependency)

    match(get?(lock-hashes, name(dependency))):
      (lock-hash: String):
        if lock-hash != compute-hash(dependency):
          error("TODO")
      (_: False): false

  false

defn write-build-stanza-proj (dependencies: HashSet<String>) -> False:
  within f = open(".poet/stanza.proj", false):
    for dep in dependencies do:
      println(f, to-string(\<>include "deps/%_/stanza.proj"<> % [dep]))
    println(f, \<>include "../stanza.proj"<>)

defn write-poet-lock-file (
  dependency-hashes: HashTable<String, String>,
  path: String
) -> False:
  dependency-hashes
    $> to-seq
    $> TomlFile
    $> spit{path, _}

public defn build (args0: Tuple<String>) -> False:
  if length(args0) > 0:
    debug("build: with '%s'" % [args0])
  else:
    debug("build")

  ensure-poet-dir-structure-exists()
  fetch-and-sync-dependencies()

  val poet-dir = to-string $ "%_/.poet" % [get-cwd()]

  val args = to-tuple $ cat-all([["stanza", "build"], args0, ["-pkg", "pkgs"]])
  ProcessBuilder(args)
    $> in-dir{_, poet-dir}
    $> build
    $> wait-process-throw-on-nonzero{_, "build failed!"}
    
  false
