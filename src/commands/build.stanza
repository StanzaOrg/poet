defpackage poet/commands/build:
  import core
  import collections

  import maybe-utils
  import semver
  import toml/parser
  import toml/file
  import toml/table
  import toml/value

  import poet/config
  import poet/git-utils
  import poet/utils
  import poet/dependency
  import poet/version

defn git-head-hash! (work-tree: String) -> String:
  git-rev-parse!(work-tree, "HEAD")

defn parse-poet-lock-file (path: String) -> HashTable<String, String>:
  slurp(path)
    $> parse-file
    $> table
    $> to-seq
    $> seq{fn (kv): key(kv) => value(kv) as String, _}
    $> to-hashtable<String, String>

defn sync-dependency-if-needed (
  dep: Dependency,
  hash?: Maybe<String>,
  force?: True|False,
) -> True|False:

  ; Sync the given dependency to the specified version tag, if one was given.
  ; Otherwise, sync it to the latest HEAD.
  defn sync (dep: Dependency) -> False:
    defn git (args: Tuple<String>) -> False:
      run-git-command-in-dir(path(dep), args)
      false

    info("build: syncing '%_'" % [spec(dep)])

    val ref = version(dep)
      $> tag?
      $> value-or{_, "HEAD"}

    val reset-ref = ref when ref != "HEAD" else "origin/HEAD"

    git(["fetch", "--quiet", "--force", "origin", ref])
    git(["reset", "--quiet", "--hard", reset-ref])

  ; Check if the dep HEAD is at the desired hash, if one was specified
  val up-to-date? = contains?(hash?, git-head-hash!(path(dep)))

  if not up-to-date?:
    if hash? is None or force?:
      sync(dep)
    else:
      error(\<>build: dependency '%_' version does not match version in poet.lock.
Either remove poet.lock or run `poet clean`<> % [name(dep)])

  up-to-date?

defn fetch-dependency (dep: Dependency) -> False:
  info("build: fetching %_" % [spec(dep)])
  run-git-command(["init", path(dep)])

  defn git (args: Tuple<String>) -> False:
    run-git-command-in-dir(path(dep), args)
    false

  git(["remote", "add", "origin", uri(dep)])

  val tag = match(version(dep)):
    (version: SemanticVersion): tag(version)
    (_: LatestVersion):
      git-remote-tag-refs(path(dep), "origin")
        $> keys
        $> filter{prefix?{_, "refs/tags/v"}, _}
        $> seq{remove-prefix?{_, "refs/tags/v"}, _}
        $> seq?{parse-semver, _}
        $> max?
        $> value-or-else{_, fn ():
          error("build: dependency '%_' was specified as 'latest', but no valid tags could be found at '%_'"
                 % [name(dep), uri(dep)])
        }
        $> tag

  val refspec = to-string("+refs/tags/%_:refs/tags/%_" % [tag, tag])

  git(["fetch", "--quiet", "origin", "--depth", "1", refspec])
  git(["checkout", "--quiet", "--force", tag])

defn ensure-poet-dir-structure-exists () -> False:
  defn create-dir! (path: String) -> True|False:
    if not file-exists?(path):
      create-dir(path)
      true

  if create-dir!(".poet/"):
    create-dir!(".poet/deps/")
    create-dir!(".poet/pkgs/")

  false

defn fetch-and-sync-dependencies () -> False:
  val resolved-dependencies = HashSet<String>()

  var dependencies-dirty? = false
  val lock-hashes = if file-exists?("poet.lock"):
    parse-poet-lock-file("poet.lock")
  else:
    HashTable<String, String>()

  defn parse-config-and-fetch-dependencies (poet-toml-path: String) -> False:
    if not file-exists?(poet-toml-path):
      throw $ Exception $
        "tried to fetch dependencies from `%_`, but it doesn't exist!"
         % [poet-toml-path]

    val dependencies? = parse-config(poet-toml-path)
      $> get?{_, "dependencies"}

    match(dependencies?: One<TomlValue>):
      val child-deps-to-sync = Vector<Dependency>()

      for dep in value!(dependencies?) as TomlTable do:
        val dependency = parse-dependency(key(dep), value(dep) as String)
          $> value-or-else{_, {
            error("build: malformed dependency '%_' given in '%_': '%_'"
                  % [key(dep), poet-toml-path, value(dep) as String])
          }}

        if not get(resolved-dependencies, name(dependency)):
          add(resolved-dependencies, name(dependency))

          val lock-hash? = get?(lock-hashes, name(dependency)) $> to-maybe
          val in-sync? = if file-exists?(path(dependency)):
            sync-dependency-if-needed(dependency, lock-hash?, false)
          else:
            fetch-dependency(dependency)

          if not in-sync?:
            add(child-deps-to-sync, dependency)
            if lock-hash? is None:
              lock-hashes[name(dependency)] = git-head-hash!(path(dependency))
              dependencies-dirty? = true

      for dep in child-deps-to-sync do:
        parse-config-and-fetch-dependencies $
          to-string("%_/poet.toml" % [path(dep)])

  parse-config-and-fetch-dependencies("poet.toml")

  if dependencies-dirty?:
    write-poet-lock-file(lock-hashes, "poet.lock")

  within f = open(".poet/stanza.proj", false):
    for dep in resolved-dependencies do:
      println(f, to-string(\<>include "deps/%_/stanza.proj"<> % [dep]))
    println(f, \<>include "../stanza.proj"<>)

defn write-poet-lock-file (lock-hashes: HashTable<String, String>, path: String) -> False:
  lock-hashes
    $> to-seq
    $> TomlFile
    $> spit{path, _}

public defn build (args0: Tuple<String>) -> False:
  ensure-poet-dir-structure-exists()
  fetch-and-sync-dependencies()

  val poet-dir = to-string("%_/.poet" % [get-cwd()])

  val args = to-tuple $ cat-all([["stanza", "build"], args0, ["-pkg", "pkgs"]])
  ProcessBuilder(args)
    $> in-dir{_, poet-dir}
    $> build
    $> wait-process-throw-on-nonzero{_, "build failed!"}
    
  false
