defpackage poet/commands/build:
  import core
  import collections
  import maybe-utils
  import poet/config
  import poet/utils
  import poet/lock
  import semver
  import toml/parser
  import toml/file
  import toml/table
  import toml/value

defstruct Dependency:
  name: String
  locator: String
  version: SemanticVersion
  hash: String

defn parse-specifier (specifier: String) -> [String, SemanticVersion]:
  val elements = to-tuple $ split(specifier, "|")
  switch(length(elements)):
    2:
      val url = elements[0]
      val version = elements[1] $> parse-semver $> expect{_, "couldn't parse '%_'" % [specifier]}
      [url, version]
    else:
      error("build: malformed specifier '%_'" % [specifier])

defn ensure-poet-dir-structure-exists () -> False:
  defn create-dir! (path: String) -> True|False:
    if not file-exists?(path):
      create-dir(path)
      true

  if create-dir!(".poet/"):
    create-dir!(".poet/deps/")
    create-dir!(".poet/pkgs/")

  false

defn sync-dependency (name: String, dir: String, hash: String) -> False:
  if git-rev-parse!(dir, "HEAD") != hash:
    error("build: can't sync '%_', out of sync with your poet.lock" % [name])

defn fetch-dependency (
  name: String,
  dir: String,
  locator: String,
  hash: String,
) -> False:
  info("build: cloning '%_' @ %_" % [name, hash])

  val url = full-url-from-locator(locator)
  shallow-clone-git-repo(url, dir)

  run-git-command-in-dir(dir, ["fetch", "--quiet", "origin", hash])
  run-git-command-in-dir(dir, ["checkout", "--quiet", "--force", hash])

  false

defn fetch-dependency (
  name: String,
  dir: String,
  locator: String,
  version: SemanticVersion,
) -> SemanticVersion:
  info("build: cloning '%_|%~'" % [name, version])

  val url = full-url-from-locator(locator)
  shallow-clone-git-repo(url, dir)

  val tag = to-string("v%~" % [version])
  val refspec = to-string("+refs/tags/%_:refs/tags/%_" % [tag, tag])
  run-git-command-in-dir(dir, ["fetch", "--quiet", "origin", refspec])
  run-git-command-in-dir(dir, ["checkout", "--quiet", "--force", tag])

  version

defn fetch-or-sync-dependency (
  name: String,
  locator: String,
  hash: String,
) -> False:
  val dep-dir = to-string(".poet/deps/%_" % [name])
  if file-exists?(dep-dir):
    sync-dependency(name, dep-dir, hash)
  else:
    fetch-dependency(name, dep-dir, locator, hash)

defn parse-poet-lock-and-resolve-dependencies () -> HashTable<String, Dependency>:
  to-hashtable<String, Dependency> $
    for dependency in parse-poet-lock-file("poet.lock") seq:
      fetch-or-sync-dependency(name(dependency), locator(dependency), hash(dependency))
      name(dependency) => Dependency(
        name(dependency),
        locator(dependency),
        version(dependency),
        hash(dependency),
      )

defn sync-dependency (
  name: String,
  dir: String,
  requested-version: SemanticVersion,
  dependencies: HashTable<String, Dependency>
) -> SemanticVersion:
  val resolved-version = get?(dependencies, name)
    $> to-maybe
    $> map{_, version}
    $> value-or{_, requested-version}

  if requested-version == resolved-version:
    requested-version
  else if not compatible?(requested-version, resolved-version):
    error("build: can't resolve dependencies: incompatible versions of `%_`\n\
           resolved:  %~\n\
           requested: %~" % [name, resolved-version, version])
  else:
    val new-version = max(requested-version, resolved-version)

    info("build: syncing '%_' to '%~'" % [name, new-version])

    val tag = to-string("v%~" % [new-version])
    run-git-command-in-dir(dir, ["fetch", "origin", tag])
    run-git-command-in-dir(dir, ["checkout", "--force", tag])
    new-version

defn parse-poet-toml-and-resolve-dependencies () -> HashTable<String, Dependency>:
  val resolved-dependencies = HashTable<String, Dependency>()

  defn parse-poet-toml (path: String) -> False:
    debug("build: parsing '%_'" % [path])

    val table = path $> parse-file $> table
    val dependencies = table["dependencies"] as TomlTable
    val newly-resolved = to-hashtable<String, Dependency> $ 
      for [name, specifier] in pairs(dependencies) seq:
        val [locator, version] = parse-specifier(specifier as String)

        val dep-dir = to-string(".poet/deps/%_" % [name])
        val resolved-version = if file-exists?(dep-dir):
          sync-dependency(name, dep-dir, version, resolved-dependencies)
        else:
          fetch-dependency(name, dep-dir, locator, version)

        name => Dependency(
          name,
          locator,
          resolved-version,
          git-rev-parse!(dep-dir, "HEAD")
        )

    for [name, dep] in pairs(newly-resolved) do:
      resolved-dependencies[name] = dep

    for dep in keys(newly-resolved) do:
      parse-poet-toml(to-string(".poet/deps/%_/poet.toml" % [dep]))

  parse-poet-toml("poet.toml")

  resolved-dependencies

defn fetch-and-sync-dependencies () -> HashTable<String, Dependency>:
  ; There are two main strategies we'll use
  ; 1. If there's a poet.lock, then we resolve all dependencies to that exact hash
  ;    using only the lockfile.
  ;
  ; 2. Otherwise we use the poet.toml
  if file-exists?("poet.lock"):
    parse-poet-lock-and-resolve-dependencies()
  else:
    parse-poet-toml-and-resolve-dependencies()

defn write-build-stanza-proj (dependencies: HashTable<String, Dependency>) -> False:
  within f = open(".poet/stanza.proj", false):
    for dep in keys(dependencies) do:
      println(f, to-string(\<>include "deps/%_/stanza.proj"<> % [dep]))
    println(f, \<>include "../stanza.proj"<>)

defn write-poet-lock-file (dependencies: HashTable<String, Dependency>) -> False:
  val locked-dependencies = for [name, dep] in pairs(dependencies) seq:
    name => TomlTable([
      "locator" => locator(dep),
      "version" => to-string(version(dep)),
      "hash" => hash(dep),
    ])

  locked-dependencies
  $> TomlFile
  $> spit{"poet.lock", _}

public defn build (args0: Tuple<String>) -> False:
  if length(args0) > 0:
    debug("build: with '%s'" % [args0])
  else:
    debug("build")

  ensure-poet-dir-structure-exists()

  val dependencies = fetch-and-sync-dependencies()

  write-build-stanza-proj(dependencies)
  write-poet-lock-file(dependencies)

  val poet-dir = to-string("%_/.poet" % [get-cwd()])

  val args = to-tuple $ cat-all([["stanza", "build"], args0, ["-pkg", "pkgs"]])
  ProcessBuilder(args)
    $> in-dir{_, poet-dir}
    $> build
    $> wait-process-throw-on-nonzero{_, "build failed!"}
    
  false
