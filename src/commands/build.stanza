defpackage poet/commands/build:
  import core
  import collections
  import poet/config
  import poet/utils
  import toml/table
  import toml/value

; TODO: run commands in parallel up to some configurable limit
; (default: number of cores?)

defn sync-dependency (dep-path: String) -> False:
  run-git-command-in-dir(dep-path, ["fetch"])
  run-git-command-in-dir(dep-path, ["checkout", "master", "--quiet"])
  run-git-command-in-dir(dep-path, ["reset", "--hard", "origin/master", "--quiet"])
  false

defn ensure-poet-dir-structure-exists () -> False:
  defn create-dir! (path: String) -> True|False:
    if not file-exists?(path):
      create-dir(path)
      true
    else:
      false

  if create-dir!(".poet/"):
    create-dir!(".poet/deps/")
    create-dir!(".poet/pkgs/")

  false

defn fetch-and-sync-dependencies () -> False:
  val dependencies = HashSet<String>()
  ; What needs to be done?
  ; - The top-level `poet.toml` needs to be parsed
  ; - Each dependency must be located, and if remote, fetched
  ; - Each dependency must have its `poet.toml` parsed, then
  ;   its dependencies fetched
  ; - We do so until we reach a fixed point (no new deps added)
  defn parse-config-and-fetch-dependencies (root: True|False, path: String) -> False:
    if not file-exists?(path):
      throw(Exception $
        "tried to fetch dependencies from `%_`, but it doesn't exist!" % [path])
    if poet/flags/verbose?:
      println("poet: parsing dependencies from `%_`" % [path])
    val dependencies? = get?(parse-config(path), "dependencies")
    match(dependencies?: One<TomlValue>):
      for dep in value!(dependencies?) as TomlTable do:
        if not get(dependencies, key(dep)):
          add(dependencies, key(dep))

          val dep-path = to-string(".poet/deps/%_" % [key(dep)])
          if file-exists?(dep-path):
            if not root:
              sync-dependency(dep-path)
          else:
            println("poet: build: debug: cloning %_" % [key(dep)])
            shallow-clone-git-repo(value(dep) as String, dep-path)

          parse-config-and-fetch-dependencies{false, _} $
            to-string("%_/poet.toml" % [dep-path])

  parse-config-and-fetch-dependencies(true, "poet.toml")

  within f = open(".poet/stanza.proj", false):
    for dep in dependencies do:
      println(f, to-string(\<>include "deps/%_/stanza.proj"<> % [dep]))
    println(f, \<>include "../stanza.proj"<>)

public defn build (args0: Tuple<String>) -> False:
  ensure-poet-dir-structure-exists()
  fetch-and-sync-dependencies()

  val poet-dir = to-string $ "%_/.poet" % [get-cwd()]

  val args = to-tuple $ cat-all([["stanza", "build"], args0, ["-pkg", "pkgs"]])
  ProcessBuilder(args)
    $> in-dir{_, poet-dir}
    $> build
    $> wait-process-throw-on-nonzero{_, "build failed!"}
    
  false
