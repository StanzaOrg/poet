defpackage poet/commands/build:
  import core
  import collections
  import maybe-utils
  import poet/config
  import poet/utils
  import poet/dependency
  import toml/parser
  import toml/file
  import toml/table
  import toml/value

defn parse-poet-lock-file (path: String) -> HashTable<String, String>:
  slurp(path)
    $> parse-file
    $> table
    $> to-seq
    $> seq{fn (kv): key(kv) => value(kv) as String , _}
    $> to-hashtable<String, String>

defn sync-dependency (
  dep: Dependency,
  hash?: Maybe<String>,
  force?: True|False,
) -> True|False:

  val head-hash = git-rev-parse!(path(dep), "HEAD")
  defn repo-head-at-hash? () -> True|False:
    hash?
      $> map{_, {_ == head-hash}}
      $> value-or{_, false}

  defn git (args: Tuple<String>):
    run-git-command-in-dir(path(dep), args)

  val up-to-date? = repo-head-at-hash?()

  if not up-to-date?:
    if hash? is One:
      if force?:
        info("build: syncing '%_'" % [spec(dep)])

        val ref = ref(dep)
        val reset-ref = ref when ref != "HEAD" else "origin/HEAD"

        git(["fetch", "--quiet", "--force", "origin", ref])
        git(["reset", "--quiet", "--hard", reset-ref])
      else:
        error(\<>build: dependency '%_' version does not match version in poet.lock.
Either remove poet.lock or run `poet clean`<> % [name(dep)])

  up-to-date?

deftype Version
defstruct IntVersion <: Version:
  major: Int
  minor: Int
  patch: Int

defstruct LatestVersion <: Version

defn parse-version (version: String) -> Maybe<Version>:
  if version == "latest":
    One(LatestVersion())
  else:
    defn parse-int! (s: String) -> Int:
      s $> to-int $> to-maybe $> value!

    val elements = to-tuple $ split(version, ".")
    if length(elements) == 3:
      val major = elements[0] $> parse-int!
      val minor = elements[1] $> parse-int!
      val patch = elements[2] $> parse-int!
      One(IntVersion(major, minor, patch))
    else:
      None()

defmulti version-tag? (version: Version) -> Maybe<String>
defmethod version-tag? (version: IntVersion) -> Maybe<String>:
  One $ to-string("v%~.%~.%~" % [major(version), minor(version), patch(version)])

defmethod version-tag? (version: LatestVersion) -> None:
  None()

defn clone-and-checkout-dependency (dep: Dependency) -> False:
  info("build: cloning %_" % [spec(dep)])

  shallow-clone-git-repo(uri(dep), path(dep))
  val revision = version(dep)
    $> parse-version
    $> and-then{_, version-tag?}
    $> map{_, fn (tag):
      val refspec = to-string $ "+refs/tags/%_:refs/tags/%_" % [tag, tag]
      run-git-command-in-dir(path(dep), ["fetch", "--quiet", "origin", refspec])
      run-git-command-in-dir(path(dep), ["checkout", "--quiet", "--force", tag])
    }
  false

defn ensure-poet-dir-structure-exists () -> False:
  defn create-dir! (path: String) -> True|False:
    if not file-exists?(path):
      create-dir(path)
      true

  if create-dir!(".poet/"):
    create-dir!(".poet/deps/")
    create-dir!(".poet/pkgs/")

  false

defn fetch-and-sync-dependencies () -> False:
  val resolved-dependencies = HashSet<String>()

  var dependencies-dirty? = false
  val lock-hashes = if file-exists?("poet.lock"):
    parse-poet-lock-file("poet.lock")
  else:
    HashTable<String, String>()

  defn parse-config-and-fetch-dependencies (poet-toml-path: String) -> False:
    debug("build: parsing %_" % [poet-toml-path])

    if not file-exists?(poet-toml-path):
      throw $ Exception $
        "tried to fetch dependencies from `%_`, but it doesn't exist!"
         % [poet-toml-path]

    val dependencies? = parse-config(poet-toml-path)
      $> get?{_, "dependencies"}

    match(dependencies?: One<TomlValue>):
      val child-deps-to-sync = Vector<Dependency>()

      for dep in value!(dependencies?) as TomlTable do:
        val dependency = parse-dependency(key(dep), value(dep) as String)
          $> value-or-else{_, {
            error("build: malformed dependency '%_' given in '%_': '%_'"
                  % [key(dep), path, value(dep) as String])
          }}

        if not get(resolved-dependencies, name(dependency)):
          add(resolved-dependencies, name(dependency))

          val lock-hash? = get?(lock-hashes, name(dependency)) $> to-maybe
          val in-sync? = if file-exists?(path(dependency)):
            sync-dependency(dependency, lock-hash?, false)
          else:
            clone-and-checkout-dependency(dependency)

          if not in-sync?:
            add(child-deps-to-sync, dependency)
            if lock-hash? is None:
              val lock-hash = git-rev-parse!(path(dependency), "HEAD")
              lock-hashes[name(dependency)] = lock-hash
              dependencies-dirty? = true

      for dep in child-deps-to-sync do:
        parse-config-and-fetch-dependencies $
          to-string("%_/poet.toml" % [path(dep)])

  parse-config-and-fetch-dependencies("poet.toml")

  if dependencies-dirty?:
    write-poet-lock-file(lock-hashes, "poet.lock")

  within f = open(".poet/stanza.proj", false):
    for dep in resolved-dependencies do:
      println(f, to-string(\<>include "deps/%_/stanza.proj"<> % [dep]))
    println(f, \<>include "../stanza.proj"<>)

defn write-poet-lock-file (
  dependency-hashes: HashTable<String, String>,
  path: String
) -> False:
  dependency-hashes
    $> to-seq
    $> TomlFile
    $> spit{path, _}

public defn build (args0: Tuple<String>) -> False:
  if length(args0) > 0:
    debug("build: with '%s'" % [args0])
  else:
    debug("build")

  ensure-poet-dir-structure-exists()
  fetch-and-sync-dependencies()

  val poet-dir = to-string $ "%_/.poet" % [get-cwd()]

  val args = to-tuple $ cat-all([["stanza", "build"], args0, ["-pkg", "pkgs"]])
  ProcessBuilder(args)
    $> in-dir{_, poet-dir}
    $> build
    $> wait-process-throw-on-nonzero{_, "build failed!"}
    
  false
